# Code Implementation Progress Summary
*Accumulated implementation progress for all files*


================================================================================
## IMPLEMENTATION File src/data_structures/__init__.py; ROUND 1 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:25:45
**File Implemented**: src/data_structures/__init__.py

**Core Purpose**:
- Package initialization module that exposes the core data structure classes for flip-chip RDL routing, providing a clean public API for importing Chip, BumpPad, IOPad, and Net classes from the data_structures package.

**Public Interface**:
- Class `Chip`: Represents the chip/package layout | Key methods: TBD (imported from chip.py) | Constructor params: TBD
- Class `BumpPad`: Represents bump pad data structure | Key methods: TBD (imported from bump_pad.py) | Constructor params: TBD
- Class `IOPad`: Represents IO pad data structure | Key methods: TBD (imported from io_pad.py) | Constructor params: TBD
- Class `Net`: Represents net/wire connections | Key methods: TBD (imported from net.py) | Constructor params: TBD
- Constants/Types: `__all__`: `['Chip', 'BumpPad', 'IOPad', 'Net']` - defines public exports

**Internal Dependencies**:
- From `.chip`: `Chip` class
- From `.bump_pad`: `BumpPad` class
- From `.io_pad`: `IOPad` class
- From `.net`: `Net` class
- External packages: None

**External Dependencies**:
- Expected to be imported by: `src/core/network_builder.py`, `src/routing/global_router.py`, `src/routing/detailed_router.py`, `src/utils/parser.py`, `main.py`
- Key exports used elsewhere: All four classes (`Chip`, `BumpPad`, `IOPad`, `Net`) are fundamental data structures used throughout the routing pipeline

**Implementation Notes**:
- Architecture decisions: Uses relative imports for sibling modules; follows Python package convention with `__all__` for explicit public API
- Cross-File Relationships: This is a facade module that aggregates all data structure classes; actual implementations reside in individual files (chip.py, bump_pad.py, io_pad.py, net.py) which must be implemented before this module can function

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/data_structures/bump_pad.py; ROUND 3 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:26:48
**File Implemented**: flip_chip_rdl_router/src/data_structures/bump_pad.py

**Core Purpose**:
- Defines the BumpPad class representing solder ball connection points in flip-chip package design, serving as targets for IO pad routing through the RDL (Redistribution Layer) with support for capacity management, geometric operations, and flow network integration.

**Public Interface**:
- Class `BumpPad`: Represents bump pad with position, capacity, and assignment tracking | Key methods: `assign_io()`, `unassign_io()`, `manhattan_distance()`, `euclidean_distance()`, `distance_to_point()`, `contains_point()`, `overlaps()`, `get_grid_position()`, `copy()`, `create_grid()`, `to_dict()`, `from_dict()` | Constructor params: `x`, `y`, `capacity=1`, `name=""`, `diameter=80.0`, `pitch=100.0`, `node_id=None`, `net_id=-1`, `is_power=False`, `is_blocked=False`
- Properties: `pos`, `position`, `remaining_capacity`, `is_full`, `is_available`, `bounding_box`
- Class method `reset_node_counter()`: Resets auto-increment node ID counter
- Class method `create_grid(rows, cols, pitch, origin_x, origin_y, diameter, capacity)` -> `List[BumpPad]`: Factory for creating bump pad arrays

**Internal Dependencies**:
- From `typing`: `List`, `Optional`, `Tuple`, `Any`
- External packages: `math` - used internally for Euclidean distance and point containment calculations

**External Dependencies**:
- Expected to be imported by: `src/data_structures/chip.py`, `src/core/network_builder.py`, `src/routing/global_router.py`, `src/routing/detailed_router.py`
- Key exports used elsewhere: `BumpPad` class for flow network construction (node_id), routing assignments (assign_io/unassign_io), and geometric calculations (distance methods)

**Implementation Notes**:
- Architecture decisions: Uses class-level `_node_counter` for automatic unique node ID assignment in flow networks; capacity model supports multi-IO bump pads; separation of Manhattan vs Euclidean distance for routing vs overlap detection
- Cross-File Relationships: `node_id` attribute integrates with MCMF flow network in `network_builder.py`; `assigned_ios` list will hold `IOPad` references; `to_dict()`/`from_dict()` enable serialization for parser/config modules

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/data_structures/io_pad.py; ROUND 5 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:28:00
**File Implemented**: flip_chip_rdl_router/src/data_structures/io_pad.py

**Core Purpose**:
- Represents IO buffer pads on the die periphery that need to be routed to bump pads through the redistribution layer (RDL). This class serves as a source terminal in the MCMF flow network with capacity 1, storing position, routing assignments, and detailed route paths.

**Public Interface**:
- Class `IOPad`: IO pad data structure for flow network | Key methods: `assign_to_bump()`, `unassign()`, `set_route_path()`, `manhattan_distance()`, `distance_to_bump()`, `contains_point()`, `overlaps()`, `copy()`, `to_dict()`, `from_dict()`, `create_peripheral_pads()`, `reset_node_counter()` | Constructor params: `x`, `y`, `net_id=-1`, `name=""`, `width=50.0`, `height=50.0`, `node_id=None`, `side="bottom"`, `layer=1`, `is_power=False`
- Property `pos` -> `Tuple[float, float]`: Returns (x, y) position tuple
- Property `bounding_box` -> `Tuple[float, float, float, float]`: Returns (x_min, y_min, x_max, y_max)
- Property `is_assigned` -> `bool`: Checks if IO pad has been assigned to a bump pad
- Static method `create_peripheral_pads(die_width, die_height, num_pads_per_side, ...)` -> `List[IOPad]`: Factory for creating pads around die periphery

**Internal Dependencies**:
- From standard library: `typing` (List, Optional, Tuple, Any), `math` (sqrt)
- External packages: None

**External Dependencies**:
- Expected to be imported by: `src/data_structures/chip.py`, `src/core/network_builder.py`, `src/routing/global_router.py`, `src/routing/detailed_router.py`, `src/core/river_router.py`
- Key exports used elsewhere: `IOPad` class for flow network construction, routing assignment tracking, and distance calculations

**Implementation Notes**:
- Architecture decisions: Uses class-level `_node_counter` for automatic unique node ID assignment in flow networks; `assigned_bump` typed as `Any` to avoid circular imports with BumpPad; supports both Manhattan (for MCMF cost) and Euclidean distance calculations
- Cross-File Relationships: Works with `BumpPad` for routing assignments; `node_id` used by `network_builder.py` for flow network edges; `route_path` populated by detailed router

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/data_structures/net.py; ROUND 7 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:29:26
**File Implemented**: flip_chip_rdl_router/src/data_structures/net.py

**Core Purpose**:
- Represents a net (electrical connection) in flip-chip RDL routing, managing connections between IO pads and bump pads, storing routing paths, wire properties, and providing methods for route analysis including crossing detection for river routing planarity constraints.

**Public Interface**:
- Class `Net`: Represents electrical connection with routing information | Key methods: `add_io_pad()`, `add_bump_pad()`, `remove_io_pad()`, `remove_bump_pad()`, `set_route_path()`, `add_route_segment()`, `clear_route()`, `get_bounding_box()`, `get_half_perimeter_wirelength()`, `get_centroid()`, `crosses()`, `would_cross()`, `copy()`, `to_dict()`, `from_dict()`, `reset_net_counter()` | Constructor params: `net_id`, `name`, `wire_width`, `wire_spacing`, `layer`, `is_power`, `priority`
- Properties: `num_pins`, `num_io_pads`, `num_bump_pads`, `is_single_pin`, `is_two_pin`, `is_multi_pin`
- Class variable `_net_counter`: Auto-incrementing counter for net ID generation

**Internal Dependencies**:
- From standard library: `typing` (List, Optional, Tuple, Any), `math`
- External packages: None

**External Dependencies**:
- Expected to be imported by: `src/data_structures/chip.py`, `src/routing/global_router.py`, `src/routing/detailed_router.py`, `src/routing/net_ordering.py`, `src/core/river_router.py`
- Key exports used elsewhere: `Net` class for managing routing connections and path information

**Implementation Notes**:
- Architecture decisions: Uses `Any` type for io_pads/bump_pads to avoid circular imports; auto-generates net IDs via class counter; stores both route_path (points) and route_segments (line segments) for flexibility
- Cross-File Relationships: Works with `IOPad` and `BumpPad` classes (sets their `net_id` attribute); `would_cross()` method specifically designed for net ordering in river routing; `crosses()` method for planarity checking in detailed routing
- Key metrics: Automatically calculates wirelength and bend count when route is set; provides HPWL estimate for routing optimization

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/data_structures/chip.py; ROUND 9 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:31:26
**File Implemented**: flip_chip_rdl_router/src/data_structures/chip.py

**Core Purpose**:
The Chip class serves as the main container for flip-chip package layout, managing all routing elements including IO pads, bump pads, nets, and RDL layer configuration. It provides comprehensive methods for chip initialization, validation, routing statistics, and serialization.

**Public Interface**:
- Class `Chip`: Main container for flip-chip routing | Key methods: `add_io_pad`, `add_bump_pad`, `add_net`, `create_bump_grid`, `create_peripheral_io_pads`, `create_nets_from_assignments`, `clear_routing`, `calculate_total_wirelength`, `get_routing_statistics`, `validate`, `to_dict`, `from_dict` | Constructor params: `name`, `die_width`, `die_height`, `rdl_layers`, `bump_pitch`, `bump_diameter`, `wire_width`, `wire_spacing`, `io_pad_width`, `io_pad_height`
- Properties: `num_io_pads`, `num_bump_pads`, `num_nets`, `die_area`, `total_bump_capacity`, `available_bump_capacity`, `is_routable`, `routing_complete`, `routability_rate`
- Lookup methods: `get_io_pad_by_name`, `get_io_pad_by_node_id`, `get_bump_pad_by_name`, `get_bump_pad_by_node_id`, `get_bump_pad_at_grid`, `get_net_by_id`, `get_net_by_name`
- Filter methods: `get_io_pads_by_side`, `get_available_bump_pads`, `get_assigned_io_pads`, `get_unassigned_io_pads`

**Internal Dependencies**:
- From `.bump_pad`: `BumpPad`
- From `.io_pad`: `IOPad`
- From `.net`: `Net`
- External packages: `typing` - type annotations (List, Optional, Tuple, Dict, Any)

**External Dependencies**:
- Expected to be imported by: `src/core/network_builder.py`, `src/routing/global_router.py`, `src/routing/detailed_router.py`, `src/utils/parser.py`, `main.py`
- Key exports used elsewhere: `Chip` class as primary data container for entire routing pipeline

**Implementation Notes**:
- Architecture decisions: Chip acts as central orchestrator holding all routing state; supports both programmatic creation (via `create_bump_grid`, `create_peripheral_io_pads`) and file-based loading (via `from_dict`); maintains routing results separately (`routed_nets`, `unrouted_nets`)
- Cross-File Relationships: Aggregates `BumpPad`, `IOPad`, and `Net` instances; delegates grid/peripheral creation to respective class factory methods; provides validation that checks bounds and capacity constraints

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/data_structures/__init__.py; ROUND 10 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:31:46
**File Implemented**: flip_chip_rdl_router/src/data_structures/__init__.py

**Core Purpose**:
- Package initialization module that exposes the core data structures (Chip, BumpPad, IOPad, Net) for flip-chip RDL routing, providing a clean public API for importing these classes from a single location.

**Public Interface**:
- Class `BumpPad`: Represents bump pad (solder ball) connection points
- Class `IOPad`: Represents IO buffer pads on die periphery
- Class `Net`: Represents electrical connections between pads
- Class `Chip`: Main container for flip-chip package layout | Key methods: `create_bump_grid()`, `create_peripheral_io_pads()` | Constructor params: `name`, `die_width`, `die_height`
- Constants/Types: `__all__`: `['Chip', 'BumpPad', 'IOPad', 'Net']` | `__version__`: `'1.0.0'`

**Internal Dependencies**:
- From `.bump_pad`: `BumpPad`
- From `.io_pad`: `IOPad`
- From `.net`: `Net`
- From `.chip`: `Chip`

**External Dependencies**:
- Expected to be imported by: `src/routing/global_router.py`, `src/routing/detailed_router.py`, `src/core/network_builder.py`, `src/utils/parser.py`, `main.py`
- Key exports used elsewhere: `Chip`, `BumpPad`, `IOPad`, `Net` classes for representing chip layout and routing elements

**Implementation Notes**:
- Architecture decisions: Uses standard Python package pattern with `__all__` for explicit public API control; re-exports all data structure classes at package level for convenient single-import access
- Cross-File Relationships: This module serves as the central access point for all data structures; the `Chip` class aggregates `BumpPad`, `IOPad`, and `Net` instances; routing modules will consume these structures for algorithm implementation

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/core/geometry.py; ROUND 12 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:33:19
**File Implemented**: flip_chip_rdl_router/src/core/geometry.py

**Core Purpose**:
This module provides fundamental geometric primitives and utilities for flip-chip RDL routing, including Point, Segment, and BoundingBox classes along with functions for intersection detection, distance calculations, path generation, and crossing detection essential for river routing planarity constraints.

**Public Interface**:
- Class `Point`: 2D coordinate representation | Key methods: `distance_to()`, `manhattan_distance_to()`, `midpoint()`, `copy()`, `from_tuple()` | Constructor params: `x: float, y: float`
- Class `Segment`: Line segment between two points | Key methods: `contains_point()`, `intersects()`, `intersection_point()`, `copy()` | Constructor params: `p1: Point, p2: Point`
- Class `BoundingBox`: Axis-aligned bounding box | Key methods: `contains_point()`, `overlaps()`, `union()`, `intersection()`, `expand()`, `from_points()` | Constructor params: `x_min, y_min, x_max, y_max: float`
- Function `cross_product(o, a, b)` -> `float`: Calculate cross product of vectors OA and OB
- Function `segments_intersect(p1, p2, p3, p4, tolerance)` -> `bool`: Check segment intersection
- Function `segment_intersection_point(p1, p2, p3, p4)` -> `Optional[Point]`: Find intersection point
- Function `manhattan_distance(p1, p2)` -> `float`: Calculate Manhattan distance
- Function `euclidean_distance(p1, p2)` -> `float`: Calculate Euclidean distance
- Function `generate_l_shape_path(start, end, horizontal_first)` -> `List[Point]`: Generate L-shaped Manhattan path
- Function `generate_z_shape_path(start, end, mid_x, mid_y)` -> `List[Point]`: Generate Z-shaped Manhattan path
- Function `simplify_path(path, tolerance)` -> `List[Point]`: Remove redundant collinear points
- Function `path_length(path)` / `path_manhattan_length(path)` -> `float`: Calculate path lengths
- Function `count_bends(path)` -> `int`: Count direction changes in path
- Function `paths_intersect(path1, path2, exclude_endpoints)` -> `bool`: Check path intersection
- Function `would_cross(io1_x, bump1_x, io2_x, bump2_x)` -> `bool`: Check if assignments cross in river routing
- Function `count_crossings(assignments)` -> `int`: Count crossing pairs
- Function `is_planar_routing(assignments)` -> `bool`: Verify planar routability

**Internal Dependencies**:
- External packages: `math` - for sqrt calculations in Euclidean distance
- External packages: `typing` - for type hints (List, Tuple, Optional, Union)

**External Dependencies**:
- Expected to be imported by: `river_router.py`, `detailed_router.py`, `global_router.py`, `net_ordering.py`, `network_builder.py`
- Key exports used elsewhere: `Point`, `Segment`, `BoundingBox`, `manhattan_distance`, `generate_l_shape_path`, `generate_z_shape_path`, `would_cross`, `is_planar_routing`, `paths_intersect`

**Implementation Notes**:
- Architecture decisions: Uses `__slots__` for memory efficiency in Point and Segment classes; tolerance-based comparisons for floating-point robustness
- Cross-File Relationships: Provides foundational geometry for all routing modules; `would_cross()` and `is_planar_routing()` directly support river routing planarity checks; path generation utilities support detailed routing

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/core/mcmf.py; ROUND 14 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:35:11
**File Implemented**: flip_chip_rdl_router/src/core/mcmf.py

**Core Purpose**:
This module implements the Minimum-Cost Maximum-Flow (MCMF) algorithm using the Successive Shortest Path approach with Bellman-Ford/SPFA optimization. It serves as the core optimization engine for global routing, finding optimal assignments between IO pads and bump pads while minimizing total wirelength.

**Public Interface**:
- Class `Edge`: Represents directed edge in flow network | Key methods: `residual_capacity` (property) | Constructor params: `to: int, capacity: int, cost: float, reverse_idx: int`
- Class `MCMF`: Main MCMF solver using adjacency list | Key methods: `add_edge`, `add_undirected_edge`, `min_cost_max_flow`, `min_cost_flow`, `get_flow_on_edge`, `get_flow_edges`, `get_cut_edges`, `reset_flow`, `get_statistics` | Constructor params: `n_nodes: int`
- Class `MCMFMatrix`: Alternative MCMF using adjacency matrix | Key methods: `add_edge`, `min_cost_max_flow`, `get_flow_on_edge`, `reset_flow` | Constructor params: `n_nodes: int`
- Function `create_bipartite_mcmf(left_nodes: int, right_nodes: int, edges: List[Tuple[int, int, float]])` -> `Tuple[MCMF, int, int]`: Creates MCMF network for bipartite matching
- Function `test_mcmf()` -> `None`: Runs validation tests
- Constants: `INF = float('inf')`

**Internal Dependencies**:
- From `collections`: `deque` - for SPFA queue implementation
- From `typing`: `List, Tuple, Optional, Dict, Any` - type annotations
- External packages: `math` - mathematical operations

**External Dependencies**:
- Expected to be imported by: `src/core/network_builder.py`, `src/routing/global_router.py`
- Key exports used elsewhere: `MCMF` class, `create_bipartite_mcmf` function

**Implementation Notes**:
- Architecture decisions: Dual implementation (adjacency list for sparse graphs, matrix for dense); SPFA optimization for faster average-case performance; `__slots__` used in Edge class for memory efficiency
- Cross-File Relationships: `network_builder.py` will construct flow networks using this module; `global_router.py` will call `min_cost_max_flow` to solve IO-to-bump assignments; results extracted via `get_flow_edges` for downstream routing

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/core/network_builder.py; ROUND 15 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:36:42
**File Implemented**: flip_chip_rdl_router/src/core/network_builder.py

**Core Purpose**:
This module constructs flow networks from chip layouts for MCMF-based global routing, creating a bipartite graph structure connecting IO pads to bump pads with Manhattan distance costs, enabling optimal IO-to-bump assignment through minimum-cost maximum-flow computation.

**Public Interface**:
- Class `NodeType(Enum)`: Node type enumeration | Values: SOURCE, SINK, IO_PAD, BUMP_PAD
- Class `NetworkNode`: Flow network node representation | Key attrs: node_id, node_type, original_id, x, y | Constructor params: node_id, node_type, original_id, name, x, y
- Class `NetworkEdge`: Flow network edge representation | Key attrs: from_node, to_node, capacity, cost, edge_type
- Class `FlowNetwork`: Complete flow network container | Key methods: get_io_node_id, get_bump_node_id, get_original_io_id, get_original_bump_id, get_node, get_io_pad, get_bump_pad
- Class `NetworkBuilder`: Main builder class | Key methods: build_network(chip), build_network_from_pads(io_pads, bump_pads, constraints), build_bipartite_network(io_pads, bump_pads, cost_matrix), extract_assignments(mcmf, network), validate_network(network), get_network_statistics(network)
- Function `build_routing_network(io_pads, bump_pads, constraints)` -> Tuple[MCMF, FlowNetwork]: Convenience function for network construction
- Function `solve_assignment(io_pads, bump_pads, constraints)` -> Tuple[List[Tuple], float, int]: Complete assignment solver returning assignments, cost, flow

**Internal Dependencies**:
- From `.mcmf`: MCMF, INF
- From `.geometry`: manhattan_distance, Point
- From `..data_structures`: IOPad, BumpPad (in test function)
- External packages: typing, dataclasses, enum, math

**External Dependencies**:
- Expected to be imported by: `src/routing/global_router.py`, `src/core/river_router.py`, `main.py`
- Key exports used elsewhere: NetworkBuilder, FlowNetwork, build_routing_network, solve_assignment

**Implementation Notes**:
- Architecture decisions: Uses dataclasses for clean node/edge representation; maintains bidirectional mappings between original IDs and network node IDs for easy result extraction
- Cross-File Relationships: Integrates MCMF solver from mcmf.py; uses geometry utilities; designed to work with data_structures module; provides foundation for global_router.py

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/routing/global_router.py; ROUND 16 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:38:07
**File Implemented**: flip_chip_rdl_router/src/routing/global_router.py

**Core Purpose**:
This module implements the global routing phase for flip-chip RDL routing using Minimum-Cost Maximum-Flow (MCMF) algorithm to optimally assign IO pads to bump pads while minimizing total wirelength, serving as the first stage of the two-stage routing approach.

**Public Interface**:
- Class `RoutingStatus(Enum)`: Routing result status | Values: SUCCESS, PARTIAL, FAILED, INFEASIBLE
- Class `Assignment`: IO-to-bump assignment | Key attrs: io_pad, bump_pad, cost, net_id | Properties: io_x, io_y, bump_x, bump_y
- Class `GlobalRoutingResult`: Routing result container | Key attrs: status, assignments, total_cost, total_flow, unrouted_ios, statistics | Properties: num_routed, num_unrouted, routability_rate, is_complete
- Class `RoutingConstraints`: Routing constraints | Key attrs: max_distance, min_distance, allowed_bump_ids, blocked_bump_ids, power_net_bumps, require_planarity | Method: is_valid_assignment(io_pad, bump_pad) -> bool
- Class `GlobalRouter`: Main router class | Constructor params: constraints (Optional[RoutingConstraints]) | Key methods: route(chip) -> GlobalRoutingResult, route_from_pads(io_pads, bump_pads) -> GlobalRoutingResult, get_assignment_matrix(io_pads, bump_pads) -> List[List[float]]
- Function `global_route(chip, constraints)`: Convenience routing function -> GlobalRoutingResult
- Function `compute_lower_bound_wirelength(io_pads, bump_pads)`: Compute theoretical minimum wirelength -> float

**Internal Dependencies**:
- From `..core.mcmf`: MCMF, INF
- From `..core.network_builder`: NetworkBuilder, FlowNetwork, build_routing_network, solve_assignment, NetworkNode, NodeType
- From `..core.geometry`: manhattan_distance, would_cross, is_planar_routing, Point
- From `..data_structures`: Chip, IOPad, BumpPad, Net
- External packages: typing, dataclasses, enum, math

**External Dependencies**:
- Expected to be imported by: detailed_router.py, layer_assignment.py, main.py, run_experiments.py
- Key exports used elsewhere: GlobalRouter, GlobalRoutingResult, Assignment, global_route, RoutingConstraints

**Implementation Notes**:
- Architecture decisions: Uses MCMF for optimal assignment with flow network where source→IO→bump→sink; supports planarity checking and automatic crossing fix via bump swapping; separates constraint validation into dedicated class
- Cross-File Relationships: Builds on MCMF solver and NetworkBuilder from core module; uses Chip/IOPad/BumpPad data structures; prepares Assignment objects for detailed routing phase; applies assignments back to chip data structures

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/core/river_router.py; ROUND 17 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:39:47
**File Implemented**: flip_chip_rdl_router/src/core/river_router.py

**Core Purpose**:
This module implements the river routing methodology for detailed single-layer RDL routing in flip-chip design. It ensures planarity (no wire crossings) by maintaining proper net ordering and generating non-crossing Manhattan paths using L-shaped and Z-shaped routing strategies.

**Public Interface**:
- Class `RouteType(Enum)`: Route shape types | Values: L_SHAPE, Z_SHAPE, STRAIGHT, CUSTOM
- Class `RoutingDirection(Enum)`: Primary routing direction | Values: HORIZONTAL_FIRST, VERTICAL_FIRST, AUTO
- Class `RouteSegment`: Single route segment | Key methods: `length`, `manhattan_length`, `is_horizontal`, `is_vertical`, `intersects()` | Constructor params: `start: Point, end: Point, layer: int=1, width: float=10.0`
- Class `Route`: Complete route from IO to bump | Key methods: `wirelength`, `manhattan_wirelength`, `num_bends`, `set_path()`, `intersects()` | Constructor params: `io_id: int, bump_id: int, path: List[Point], layer: int=1, width: float=10.0`
- Class `RiverRoutingResult`: Routing result container | Key attrs: `routes`, `success`, `total_wirelength`, `num_routed`, `num_failed`, `crossings`, `routability_rate`
- Class `RiverRouter`: Main river routing algorithm | Key methods: `add_obstacle()`, `check_routability()`, `order_nets()`, `route()`, `route_single()`, `get_statistics()` | Constructor params: `wire_width: float=10.0, wire_spacing: float=10.0, layer: int=1, routing_direction: RoutingDirection=AUTO`
- Function `river_route(io_pads, bump_pads, assignments, wire_width, wire_spacing)` -> `RiverRoutingResult`: Convenience function for river routing
- Function `check_planarity(assignments)` -> `Tuple[bool, int]`: Check if assignments can be routed without crossings

**Internal Dependencies**:
- From `.geometry`: Point, Segment, BoundingBox, manhattan_distance, euclidean_distance, generate_l_shape_path, generate_z_shape_path, simplify_path, path_length, path_manhattan_length, count_bends, paths_intersect, would_cross, is_planar_routing, segments_intersect
- External packages: `typing` - type hints; `dataclasses` - data structures; `enum` - enumerations; `math` - mathematical operations

**External Dependencies**:
- Expected to be imported by: `detailed_router.py`, `global_router.py`, `main.py`
- Key exports used elsewhere: `RiverRouter`, `Route`, `RiverRoutingResult`, `river_route()`, `check_planarity()`

**Implementation Notes**:
- Architecture decisions: Uses topological sort (Kahn's algorithm) for net ordering to avoid crossing conflicts; tries L-shape routing first, then Z-shape with multiple midpoint ratios as fallback
- Cross-File Relationships: Works with geometry module for path generation and intersection checks; produces Route objects consumed by detailed_router; integrates with global_router assignments

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/routing/detailed_router.py; ROUND 19 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:41:33
**File Implemented**: flip_chip_rdl_router/src/routing/detailed_router.py

**Core Purpose**
This module implements the detailed routing phase for flip-chip RDL routing, converting global routing assignments into actual wire paths using river routing methodology. It handles DRC (Design Rule Check) compliance, obstacle avoidance, and wire path optimization with L-shape and Z-shape routing strategies.

**Public Interface**
- Class `DetailedRoutingStatus(Enum)`: Routing result status | Values: SUCCESS, PARTIAL, FAILED, DRC_VIOLATION
- Class `DRCViolationType(Enum)`: DRC violation types | Values: SPACING, WIDTH, CROSSING, SHORT, OPEN, BOUNDARY
- Class `DRCViolation`: Represents a DRC violation | Key attrs: violation_type, net_id, location, description, severity
- Class `DetailedRoute`: Complete route for a net | Key methods: wirelength, num_bends, has_violations, get_bounding_box, to_segments | Constructor params: net_id, io_pad, bump_pad, path, segments, layer, wire_width, route_type, is_valid
- Class `DetailedRoutingResult`: Routing result container | Key methods: routability_rate, is_complete, is_drc_clean, get_route_by_net | Key attrs: status, routes, total_wirelength, num_routed, num_failed, drc_violations
- Class `DRCChecker`: Design rule checker | Key methods: check_route, check_all_routes | Constructor params: min_spacing, min_width, boundary
- Class `DetailedRouter`: Main detailed router | Key methods: set_boundary, add_obstacle, route, route_assignments, route_single | Constructor params: wire_width, wire_spacing, layer, routing_direction, enable_drc
- Function `detailed_route(chip, wire_width, wire_spacing, enable_drc)` -> DetailedRoutingResult: Convenience routing function
- Function `route_with_global(chip, wire_width, wire_spacing)` -> Tuple[GlobalRoutingResult, DetailedRoutingResult]: Combined global+detailed routing

**Internal Dependencies**
- From `..core.geometry`: Point, Segment, BoundingBox, manhattan_distance, generate_l_shape_path, generate_z_shape_path, simplify_path, path_length, path_manhattan_length, count_bends, paths_intersect, segments_intersect
- From `..core.river_router`: RiverRouter, Route, RouteSegment, RiverRoutingResult, RouteType, RoutingDirection, river_route, check_planarity
- From `..data_structures`: Chip, IOPad, BumpPad, Net
- External packages: typing, dataclasses, enum, math

**External Dependencies**
- Expected to be imported by: `main.py`, `experiments/run_experiments.py`, `experiments/evaluate.py`
- Key exports used elsewhere: DetailedRouter, DetailedRoutingResult, detailed_route, route_with_global

**Implementation Notes**
- Architecture decisions: Uses composition with RiverRouter for core routing; DRC checking is optional and modular; supports both chip-level and assignment-level routing interfaces
- Cross-File Relationships: Integrates with global_router.py via route_with_global; depends heavily on river_router.py for actual path generation; uses geometry.py primitives for path manipulation and collision detection
- Routing strategy: Attempts L-shape first (horizontal-first, then vertical-first), falls back to Z-shape with multiple midpoint ratios

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/routing/net_ordering.py; ROUND 21 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:43:14
**File Implemented**: flip_chip_rdl_router/src/routing/net_ordering.py

**Core Purpose**
This module implements net ordering algorithms for river routing in flip-chip RDL design, determining the sequence in which nets should be routed to ensure planar (crossing-free) routing by analyzing crossing constraints and building precedence graphs.

**Public Interface**
- Class `OrderingStrategy(Enum)`: Enumeration of ordering strategies | Values: TOPOLOGICAL, LEFT_TO_RIGHT, RIGHT_TO_LEFT, BOTTOM_TO_TOP, TOP_TO_BOTTOM, MINIMUM_CROSSING, HYBRID
- Class `OrderingStatus(Enum)`: Status of ordering result | Values: SUCCESS, CYCLE_DETECTED, PARTIAL, FAILED
- Class `NetAssignment`: Represents net assignment for ordering | Key methods: `crosses()`, `io_pos`, `bump_pos` | Constructor params: net_id, io_x, io_y, bump_x, bump_y, io_pad, bump_pad, priority
- Class `PrecedenceGraph`: Graph for net ordering constraints | Key methods: `add_node()`, `add_edge()`, `detect_cycle()`, `topological_sort()`, `to_dict()` | Constructor params: none
- Class `OrderingResult`: Result container | Key properties: `is_valid`, `num_nets` | Fields: status, ordered_nets, ordered_assignments, precedence_graph, num_crossings, cycle_nets, statistics
- Class `NetOrderer`: Main ordering algorithm | Key methods: `set_assignments()`, `add_assignment()`, `build_precedence_graph()`, `order_nets()`, `check_routability()`, `get_statistics()` | Constructor params: strategy
- Function `order_nets(assignments, strategy)`: Convenience function to order nets from IO-bump tuples -> OrderingResult
- Function `must_route_before(net_i, net_j)`: Check if net_i must be routed before net_j -> bool
- Function `find_optimal_ordering(assignments)`: Find optimal ordering minimizing crossings -> List[NetAssignment]

**Internal Dependencies**
- From `..core.geometry`: Point, manhattan_distance, would_cross, is_planar_routing
- External packages: `typing`, `dataclasses`, `enum`, `collections.deque`, `math`

**External Dependencies**
- Expected to be imported by: `flip_chip_rdl_router/src/routing/detailed_router.py`, `flip_chip_rdl_router/src/core/river_router.py`
- Key exports used elsewhere: `NetOrderer`, `order_nets()`, `OrderingResult`, `OrderingStrategy`

**Implementation Notes**
- Architecture decisions: Uses precedence graph with topological sort for crossing-free ordering; supports multiple strategies with fallback mechanisms; Kahn's algorithm for topological sort, DFS for cycle detection
- Cross-File Relationships: Works with geometry module for crossing detection; provides ordered nets to river_router and detailed_router for sequential routing

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/routing/layer_assignment.py; ROUND 25 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:46:50
**File Implemented**: flip_chip_rdl_router/src/routing/layer_assignment.py

**Core Purpose**:
This module handles RDL layer assignment for multi-layer routing scenarios, assigning routes to appropriate redistribution layers while managing via placement and layer transitions. For single-layer RDL (the primary focus), it provides validation and simple assignment; for multi-layer scenarios, it implements various layer assignment optimization strategies.

**Public Interface**:
- Class `LayerType(Enum)`: Layer type classification | Values: SIGNAL, POWER, GROUND, MIXED
- Class `AssignmentStrategy(Enum)`: Assignment strategies | Values: SINGLE_LAYER, GREEDY, LOAD_BALANCED, CROSSING_BASED, CONGESTION_AWARE
- Class `AssignmentStatus(Enum)`: Assignment result status | Values: SUCCESS, PARTIAL, FAILED, INSUFFICIENT_LAYERS
- Class `Via`: Via connecting two layers | Key methods: overlaps(), to_dict(), from_dict() | Constructor params: x, y, from_layer, to_layer, diameter, name, net_id
- Class `LayerRoute`: Route segment on specific layer | Key methods: wirelength, bounding_box, intersects() | Constructor params: net_id, layer, path, wire_width
- Class `LayerInfo`: Layer metadata | Key methods: is_full, available_capacity | Constructor params: layer_id, layer_type, wire_width, wire_spacing, capacity
- Class `LayerAssignmentResult`: Assignment result container | Key methods: get_layer_for_net(), get_nets_on_layer(), get_vias_for_net() | Properties: num_assigned, is_complete
- Class `LayerAssigner`: Main layer assignment algorithm | Key methods: assign(), add_route(), clear(), get_statistics() | Constructor params: num_layers, strategy, wire_width, wire_spacing, via_diameter
- Function `assign_layers(routes, num_layers, strategy)`: Convenience function for layer assignment -> LayerAssignmentResult
- Function `assign_chip_layers(chip, strategy)`: Assign layers for chip's routed nets -> LayerAssignmentResult
- Function `validate_single_layer_routing(routes)`: Validate single-layer routability -> Tuple[bool, int]

**Internal Dependencies**:
- From `..core.geometry`: Point, Segment, BoundingBox, manhattan_distance, paths_intersect
- From `..data_structures`: Chip, IOPad, BumpPad, Net
- External packages: math (calculations), typing (type hints), dataclasses (data structures), enum (enumerations)

**External Dependencies**:
- Expected to be imported by: `main.py`, `experiments/evaluate.py`, `detailed_router.py`
- Key exports used elsewhere: LayerAssigner, assign_layers, assign_chip_layers, LayerAssignmentResult, Via

**Implementation Notes**:
- Architecture decisions: Supports five assignment strategies with single-layer as default for flip-chip RDL; uses graph coloring approach for crossing-based assignment; calculates load balance metric for multi-layer scenarios
- Cross-File Relationships: Works with detailed_router.py output (routes), uses geometry.py for intersection detection, integrates with Chip data structure for chip-level assignment

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/utils/parser.py; ROUND 27 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:48:40
**File Implemented**: flip_chip_rdl_router/src/utils/parser.py

**Core Purpose**
- Provides comprehensive input file parsing capabilities for flip-chip RDL routing configurations, supporting YAML, JSON, text, and simplified DEF formats, along with benchmark generation utilities for testing and evaluation.

**Public Interface**
- Class `ParseResult`: Container for parsing results | Key methods: `add_error()`, `add_warning()` | Constructor params: `success`, `chip`, `errors`, `warnings`, `statistics`
- Class `ChipParser`: Multi-format configuration parser | Key methods: `parse(file_path)` | Constructor params: none
- Class `BenchmarkGenerator`: Synthetic test case generator | Key methods: `generate_grid_benchmark()`, `generate_random_benchmark()`, `generate_standard_benchmarks()` | Static class
- Function `save_chip_to_yaml(chip, file_path)`: Save chip to YAML -> `bool`
- Function `save_chip_to_json(chip, file_path, indent=2)`: Save chip to JSON -> `bool`
- Function `load_chip(file_path)`: Convenience loader -> `Optional[Chip]`
- Function `test_parser()`: Module self-test -> `None`

**Internal Dependencies**
- From `..data_structures`: `Chip`, `BumpPad`, `IOPad`, `Net`
- External packages: `json` (JSON parsing), `yaml` (optional YAML parsing), `pathlib.Path` (file handling), `dataclasses` (result container)

**External Dependencies**
- Expected to be imported by: `main.py`, `experiments/run_experiments.py`, `experiments/evaluate.py`
- Key exports used elsewhere: `ChipParser`, `BenchmarkGenerator`, `load_chip`, `save_chip_to_json`

**Implementation Notes**
- Architecture decisions: Optional YAML support with graceful fallback; multiple format support via suffix detection; ParseResult pattern for error handling
- Cross-File Relationships: Parser creates Chip objects populated with BumpPad, IOPad, and Net instances; BenchmarkGenerator uses Chip's factory methods (`create_bump_grid`, `create_peripheral_io_pads`)
- Supports GRID and PERIPHERAL keywords in text format for bulk pad creation
- DEF parser handles simplified subset (DESIGN, DIEAREA, COMPONENTS, PINS, NETS sections)

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/utils/__init__.py; ROUND 28 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:49:04
**File Implemented**: flip_chip_rdl_router/src/utils/__init__.py

**Core Purpose**:
- Package initialization module for the utils subpackage that exposes parsing utilities for loading chip configurations from various file formats (YAML, JSON, text, DEF) and provides benchmark generation capabilities for testing the RDL routing system.

**Public Interface**:
- Class `ChipParser`: Parses chip configuration files | Key methods: parse(), parse_yaml(), parse_json() | Constructor params: none specified
- Class `ParseResult`: Container for parsed chip data | Key methods: not specified | Constructor params: not specified
- Class `BenchmarkGenerator`: Generates test benchmark configurations | Key methods: not specified | Constructor params: not specified
- Function `load_chip(path)`: Convenience function to load chip from file -> Chip: Loads and returns chip configuration
- Function `save_chip_to_yaml(chip, path)`: Saves chip configuration to YAML format -> None: Serializes chip data
- Function `save_chip_to_json(chip, path)`: Saves chip configuration to JSON format -> None: Serializes chip data

**Internal Dependencies**:
- From `.parser`: ChipParser, ParseResult, BenchmarkGenerator, load_chip, save_chip_to_yaml, save_chip_to_json
- Future import from `.visualizer`: RoutingVisualizer, visualize_routing, save_routing_image (commented out, pending implementation)

**External Dependencies**:
- Expected to be imported by: `flip_chip_rdl_router/main.py`, `flip_chip_rdl_router/experiments/run_experiments.py`, `flip_chip_rdl_router/experiments/evaluate.py`
- Key exports used elsewhere: `load_chip` for loading test cases, `ChipParser` for custom parsing, `BenchmarkGenerator` for creating test data

**Implementation Notes**:
- Architecture decisions: Clean separation between parsing and visualization utilities; lazy import pattern planned for visualizer module
- Cross-File Relationships: Acts as facade for utils subpackage, re-exporting parser module contents; will integrate visualizer when implemented
- Version tracking: Includes `__version__ = '1.0.0'` for package versioning

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/core/__init__.py; ROUND 29 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:49:36
**File Implemented**: flip_chip_rdl_router/src/core/__init__.py

**Core Purpose**:
- Package initialization file that exposes the core algorithms module's public API, consolidating imports from geometry, MCMF, network_builder, and river_router submodules into a unified interface for flip-chip RDL routing operations.

**Public Interface**:
- Class `Point`: 2D coordinate representation | Key methods: arithmetic operators | Constructor params: x, y
- Class `Segment`: Line segment between two points | Key methods: intersection checks | Constructor params: start, end
- Class `BoundingBox`: Rectangular boundary | Key methods: containment checks | Constructor params: min/max coordinates
- Class `Edge`: Flow network edge | Key methods: residual capacity | Constructor params: to, cap, cost, flow
- Class `MCMF`: Min-cost max-flow solver | Key methods: add_edge, min_cost_max_flow | Constructor params: n_nodes
- Class `MCMFMatrix`: Matrix-based MCMF implementation | Key methods: add_edge, solve | Constructor params: n_nodes
- Class `FlowNetwork`: Network representation | Key methods: add_node, add_edge | Constructor params: none
- Class `NetworkBuilder`: Constructs flow networks from chip data | Key methods: build | Constructor params: chip
- Class `RiverRouter`: Detailed routing engine | Key methods: route | Constructor params: assignments, constraints
- Class `Route`: Single net route | Key methods: path access | Constructor params: segments
- Function `manhattan_distance(p1, p2)`: Calculate L1 distance -> float
- Function `build_routing_network(chip)`: Create flow network from chip -> FlowNetwork
- Function `solve_assignment(network)`: Run MCMF on network -> assignments
- Function `river_route(assignments)`: Generate detailed routes -> RiverRoutingResult
- Constants/Types: `INF`: Infinity constant for MCMF; `NodeType`, `RouteType`, `RoutingDirection`: Enum types

**Internal Dependencies**:
- From `.geometry`: Point, Segment, BoundingBox, distance functions, path generation utilities
- From `.mcmf`: Edge, MCMF, MCMFMatrix, create_bipartite_mcmf, INF
- From `.network_builder`: NodeType, NetworkNode, NetworkEdge, FlowNetwork, NetworkBuilder, build_routing_network, solve_assignment
- From `.river_router`: RouteType, RoutingDirection, RouteSegment, Route, RiverRoutingResult, RiverRouter, river_route, check_planarity

**External Dependencies**:
- Expected to be imported by: `flip_chip_rdl_router/src/routing/global_router.py`, `flip_chip_rdl_router/src/routing/detailed_router.py`, `flip_chip_rdl_router/main.py`
- Key exports used elsewhere: MCMF solver, NetworkBuilder, RiverRouter, geometry utilities

**Implementation Notes**:
- Architecture decisions: Flat namespace design allows importing all core functionality from single package; version tracking included (`__version__ = '1.0.0'`)
- Cross-File Relationships: Acts as facade pattern, simplifying imports for routing modules; global_router uses MCMF/NetworkBuilder, detailed_router uses RiverRouter/geometry

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/routing/__init__.py; ROUND 30 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:50:24
**File Implemented**: flip_chip_rdl_router/src/routing/__init__.py

**Core Purpose**:
- Package initialization module that exports all routing components for flip-chip RDL routing, providing a unified interface to global routing (MCMF-based), detailed routing (river routing), net ordering, and layer assignment functionality, along with convenience functions for complete routing pipelines.

**Public Interface**:
- Function `full_routing_pipeline(chip, constraints=None, wire_width=10.0, wire_spacing=10.0, enable_drc=True, num_layers=1, layer_strategy=None)`: Executes complete routing pipeline (global→detailed→layer assignment) -> dict with results and statistics
- Function `quick_route(chip, wire_width=10.0, wire_spacing=10.0)`: Simplified routing with defaults -> tuple(success: bool, total_wirelength: float, num_routed: int)
- Re-exports from global_router: `GlobalRouter`, `GlobalRoutingResult`, `Assignment`, `RoutingConstraints`, `RoutingStatus`, `global_route`, `compute_lower_bound_wirelength`
- Re-exports from detailed_router: `DetailedRouter`, `DetailedRoutingResult`, `DetailedRoute`, `DetailedRoutingStatus`, `DRCChecker`, `DRCViolation`, `DRCViolationType`, `detailed_route`, `route_with_global`
- Re-exports from net_ordering: `NetOrderer`, `OrderingResult`, `OrderingStrategy`, `OrderingStatus`, `NetAssignment`, `PrecedenceGraph`, `order_nets`, `must_route_before`, `find_optimal_ordering`
- Re-exports from layer_assignment: `LayerAssigner`, `LayerAssignmentResult`, `LayerRoute`, `LayerInfo`, `Via`, `LayerType`, `AssignmentStrategy`, `AssignmentStatus`, `assign_layers`, `assign_chip_layers`, `validate_single_layer_routing`
- Constants: `__version__`: '1.0.0'

**Internal Dependencies**:
- From `.global_router`: GlobalRouter, GlobalRoutingResult, Assignment, RoutingConstraints, RoutingStatus, global_route, compute_lower_bound_wirelength
- From `.detailed_router`: DetailedRouter, DetailedRoutingResult, DetailedRoute, DetailedRoutingStatus, DRCChecker, DRCViolation, DRCViolationType, detailed_route, route_with_global
- From `.net_ordering`: NetOrderer, OrderingResult, OrderingStrategy, OrderingStatus, NetAssignment, PrecedenceGraph, order_nets, must_route_before, find_optimal_ordering
- From `.layer_assignment`: LayerAssigner, LayerAssignmentResult, LayerRoute, LayerInfo, Via, LayerType, AssignmentStrategy, AssignmentStatus, assign_layers, assign_chip_layers, validate_single_layer_routing

**External Dependencies**:
- Expected to be imported by: `main.py`, `experiments/run_experiments.py`, `experiments/evaluate.py`
- Key exports used elsewhere: `full_routing_pipeline`, `quick_route`, all routing classes and functions

**Implementation Notes**:
- Architecture decisions: Provides both granular access to individual routing stages and high-level convenience functions for complete pipelines
- Cross-File Relationships: Acts as facade pattern, aggregating all routing submodules; `full_routing_pipeline` orchestrates GlobalRouter→DetailedRouter→LayerAssigner sequence with proper error handling at each stage

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/src/__init__.py; ROUND 31 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:51:13
**File Implemented**: flip_chip_rdl_router/src/__init__.py

**Core Purpose**:
- Main package initialization file that serves as the central API entry point for the flip-chip RDL router, consolidating all exports from subpackages (data_structures, core, routing, utils) and providing convenience functions for quick chip creation and routing.

**Public Interface**:
- Class `Chip`: Main chip representation | Key methods: `create_bump_grid()`, `create_peripheral_io_pads()` | Constructor params: `name, die_width, die_height, bump_pitch`
- Function `create_simple_chip(name, die_size, bump_grid, io_per_side, bump_pitch)` -> `Chip`: Quick chip setup for testing
- Function `route_chip(chip, wire_width, wire_spacing, enable_drc)` -> `dict`: Full routing pipeline convenience wrapper
- Function `get_version()` -> `str`: Returns package version string
- Function `get_info()` -> `dict`: Returns package metadata dictionary
- Constants: `__version__`: '1.0.0', `__all__`: Complete list of 70+ public exports

**Internal Dependencies**:
- From `.data_structures`: `Chip`, `BumpPad`, `IOPad`, `Net`
- From `.core`: `Point`, `Segment`, `MCMF`, `NetworkBuilder`, `RiverRouter`, geometry functions
- From `.routing`: `GlobalRouter`, `DetailedRouter`, `NetOrderer`, `LayerAssigner`, `full_routing_pipeline`, `quick_route`
- From `.utils`: `ChipParser`, `ParseResult`, `BenchmarkGenerator`, `load_chip`, save functions

**External Dependencies**:
- Expected to be imported by: `main.py`, `experiments/run_experiments.py`, `experiments/evaluate.py`, external user scripts
- Key exports used elsewhere: `Chip`, `full_routing_pipeline`, `quick_route`, `GlobalRouter`, `DetailedRouter`, all core algorithm classes

**Implementation Notes**:
- Architecture decisions: Flat namespace design exposing all major classes/functions at package level for ease of use; separates convenience functions (`create_simple_chip`, `route_chip`) from core algorithm exports
- Cross-File Relationships: Acts as facade pattern aggregating all 4 subpackages; `route_chip()` delegates to `full_routing_pipeline()` from routing module

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/main.py; ROUND 34 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:55:20
**File Implemented**: flip_chip_rdl_router/main.py

**Core Purpose**
- Main entry point and CLI for the Flip-Chip RDL Router application, providing command-line interface, interactive mode, benchmark execution, and demonstration capabilities for the network-flow-based RDL routing algorithm.

**Public Interface**
- Function `print_banner()`: Displays application banner with version info -> None
- Function `print_chip_info(chip: Chip)`: Prints chip configuration details -> None
- Function `print_routing_results(results: Dict[str, Any])`: Displays routing results summary -> None
- Function `run_demo()`: Executes demonstration with sample chip -> Dict[str, Any]
- Function `run_benchmark(benchmark_name: str, verbose: bool = True)`: Runs specific benchmark configuration -> Optional[Dict]
- Function `run_all_benchmarks()`: Executes all standard benchmarks with summary table -> None
- Function `route_from_file(file_path: str, output_path: Optional[str] = None, verbose: bool = True)`: Routes chip from config file -> Optional[Dict]
- Function `interactive_mode()`: Runs interactive REPL for experimentation -> None
- Function `main()`: Main entry point with argparse CLI -> int (exit code)

**Internal Dependencies**
- From `src`: Chip, BumpPad, IOPad, Net (data structures)
- From `src`: MCMF, NetworkBuilder, RiverRouter, Point, manhattan_distance (core algorithms)
- From `src`: GlobalRouter, DetailedRouter, LayerAssigner, routing result types, full_routing_pipeline, quick_route (routing)
- From `src`: ChipParser, BenchmarkGenerator, load_chip, save_chip_to_json, save_chip_to_yaml (utilities)
- From `src`: create_simple_chip, route_chip, get_version, get_info (convenience functions)
- External packages: argparse, sys, time, pathlib.Path, typing

**External Dependencies**
- Expected to be imported by: Shell/command-line execution, experiment scripts
- Key exports used elsewhere: None (entry point only)

**Implementation Notes**
- Architecture decisions: Supports multiple modes (demo, benchmark, file-based, interactive) via argparse
- CLI supports benchmarks: small (5x5), medium (15x15), large (30x30), xlarge (50x50), or custom NxM
- Interactive mode provides REPL with commands: create, load, info, route, benchmark, demo, save, quit
- Cross-File Relationships: Integrates all package components through src/__init__.py exports

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/requirements.txt; ROUND 35 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:55:47
**File Implemented**: flip_chip_rdl_router/requirements.txt

**Core Purpose**
- Defines all Python package dependencies required to run the flip-chip RDL routing algorithm, including core libraries for numerical computation, graph algorithms, visualization, and testing frameworks.

**Public Interface**
- Not applicable (configuration file, not code)
- Specifies package versions for pip installation

**Internal Dependencies**
- None (this is a dependency specification file)

**External Dependencies**
- numpy>=1.21.0: Matrix operations for flow network representation
- scipy>=1.7.0: Sparse matrix support and optimization algorithms
- networkx>=2.6: Graph algorithms for validation purposes
- matplotlib>=3.4.0: Visualization of routing results
- pyyaml>=5.4: YAML configuration file parsing
- pytest>=6.2.0: Unit and integration testing framework
- pytest-cov>=2.12.0: Test coverage reporting

**Implementation Notes**
- Architecture decisions: Separates dependencies into categories (core, testing, optional performance, development, documentation)
- Optional dependencies commented out: numba for JIT compilation, tqdm for progress bars, black/flake8/mypy for code quality
- Minimum version constraints ensure compatibility with Python 3.8+
- Cross-File Relationships: All Python modules in the project depend on these packages being installed; main.py, visualizer.py, and experiment scripts are primary consumers

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/config.yaml; ROUND 36 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:56:34
**File Implemented**: flip_chip_rdl_router/config.yaml

**Core Purpose**
- YAML configuration file that defines all default parameters, settings, and options for the flip-chip RDL routing system, including chip dimensions, routing algorithms, design rules, benchmark configurations, and output settings.

**Public Interface**
- Section `chip`: Die dimensions, bump pad grid configuration, IO pad settings
- Section `routing`: Wire/via properties, global routing (MCMF), detailed routing (river), net ordering, layer assignment
- Section `design_rules`: DRC parameters including spacing, width, boundary margins
- Section `algorithm`: MCMF and river routing algorithm-specific parameters
- Section `benchmarks`: Predefined test configurations (small, medium, large, xlarge)
- Section `output`: Directory, formats, visualization, statistics settings
- Section `logging`: Log level, format, file output configuration
- Section `performance`: Parallelization, memory optimization, progress reporting
- Section `experimental`: Feature flags for multi-layer, timing-driven, congestion-aware routing

**Internal Dependencies**
- None (standalone configuration file)
- External packages: PyYAML - for parsing this configuration

**External Dependencies**
- Expected to be imported by: `main.py`, `run_experiments.py`, `parser.py`
- Key exports used elsewhere: All configuration sections accessed via YAML parsing

**Implementation Notes**
- Architecture decisions: Hierarchical YAML structure with logical groupings; all dimensions in micrometers; sensible defaults for single-layer RDL routing
- Cross-File Relationships: `parser.py` loads this config; `main.py` uses settings to initialize routing; `visualizer.py` reads output/visualization settings; benchmark configs used by experiment scripts
- Default values align with paper's focus on single-layer MCMF-based routing with river routing for detailed phase

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/experiments/run_experiments.py; ROUND 37 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 00:58:18
**File Implemented**: flip_chip_rdl_router/experiments/run_experiments.py

**Core Purpose**:
This file provides a comprehensive experiment execution framework for benchmarking and evaluating the network-flow-based RDL routing algorithm, supporting standard benchmarks, scalability analysis, custom configurations, and statistical analysis with multiple runs.

**Public Interface**:
- Class `ExperimentConfig`: Dataclass for experiment configuration | Key fields: name, num_ios, bump_rows, bump_cols, die_width, die_height, bump_pitch, wire_width, wire_spacing, enable_drc, num_layers, num_runs
- Class `ExperimentResult`: Dataclass for single experiment results | Key methods: to_dict() | Fields: timing metrics, routing metrics, wirelength metrics, quality metrics
- Class `ExperimentSummary`: Dataclass for aggregated results | Key methods: to_dict() | Fields: averaged metrics, best/worst cases, success_rate, results list
- Class `ExperimentRunner`: Main experiment runner | Key methods: run_single_experiment(), run_benchmark(), run_all_benchmarks(), run_scalability_analysis(), run_custom_experiment(), save_results(), generate_report() | Constructor params: output_dir, verbose
- Function `run_quick_test()`: Runs quick verification test -> bool
- Function `main()`: CLI entry point with argparse -> int
- Constants: `STANDARD_BENCHMARKS` (dict of predefined configs), `SCALABILITY_CONFIGS` (list of size tuples)

**Internal Dependencies**:
- From `src.data_structures`: Chip, BumpPad, IOPad, Net
- From `src.core`: MCMF, NetworkBuilder, RiverRouter, Point, manhattan_distance
- From `src.routing`: GlobalRouter, DetailedRouter, LayerAssigner, GlobalRoutingResult, DetailedRoutingResult, LayerAssignmentResult, RoutingConstraints, RoutingStatus, DetailedRoutingStatus, full_routing_pipeline, quick_route
- From `src.utils`: ChipParser, BenchmarkGenerator, load_chip, save_chip_to_json
- External packages: sys, time, json, argparse, pathlib, dataclasses, datetime, math

**External Dependencies**:
- Expected to be imported by: evaluate.py, main.py, test scripts
- Key exports used elsewhere: ExperimentRunner, ExperimentConfig, ExperimentResult, ExperimentSummary

**Implementation Notes**:
- Architecture decisions: Uses dataclasses for clean configuration/result structures; supports CLI with argparse; implements statistical averaging across multiple runs; provides both JSON and text report outputs
- Cross-File Relationships: Integrates all routing components (GlobalRouter, DetailedRouter, LayerAssigner) into unified benchmarking pipeline; creates chips using Chip.create_bump_grid() and create_peripheral_io_pads()

---
*Auto-generated by Memory Agent*



================================================================================
## IMPLEMENTATION File flip_chip_rdl_router/README.md; ROUND 42 
================================================================================

# Code Implementation Summary
**Generated**: 2025-12-18 01:03:41
**File Implemented**: flip_chip_rdl_router/README.md

**Core Purpose**:
- Comprehensive documentation file providing project overview, installation instructions, usage examples, API reference, and troubleshooting guide for the Flip-Chip RDL Router implementation.

**Public Interface**:
- Documentation sections: Overview, Features, Installation, Quick Start, Project Structure, Algorithm Details, Configuration, Benchmarks, API Reference, Testing, Visualization, Troubleshooting
- Code examples: CLI usage patterns, Python API demonstrations, configuration templates
- Reference tables: Benchmark specifications, routing strategies, expected results

**Internal Dependencies**:
- References all src/ modules: core (mcmf, network_builder, river_router, geometry), routing (global_router, detailed_router, net_ordering, layer_assignment), data_structures (chip, bump_pad, io_pad, net), utils (parser, visualizer)
- References experiments/: run_experiments.py, evaluate.py
- References config files: config.yaml, requirements.txt

**External Dependencies**:
- Expected to be read by: End users, developers, contributors
- Key exports documented: Chip class, GlobalRouter, DetailedRouter, full_routing_pipeline(), quick_route(), create_simple_chip(), load_chip()

**Implementation Notes**:
- Architecture decisions: Two-stage routing (global MCMF + detailed river routing), modular design with clear separation of concerns
- Cross-File Relationships: Documents complete data flow from Chip creation → GlobalRouter (MCMF assignment) → DetailedRouter (river routing) → Visualizer (output)
- Provides complete API reference matching implemented class interfaces
- Includes benchmark specifications matching experiments/run_experiments.py configurations

---
*Auto-generated by Memory Agent*


